<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Context API and State Management</title>
    <style>
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            line-height: 1.6;
            max-width: 800px;
            margin: 0 auto;
            padding: 20px;
            color: #333;
        }
        .lesson-header {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 30px;
            border-radius: 10px;
            margin-bottom: 30px;
            text-align: center;
        }
        .lesson-number {
            font-size: 14px;
            opacity: 0.9;
            margin-bottom: 10px;
        }
        h1 {
            margin: 0;
            font-size: 2.5em;
        }
        .lesson-duration {
            font-size: 16px;
            opacity: 0.9;
            margin-top: 10px;
        }
        .code-block {
            background: #f8f9fa;
            border: 1px solid #e9ecef;
            border-radius: 6px;
            padding: 20px;
            margin: 20px 0;
            font-family: 'Courier New', monospace;
            overflow-x: auto;
        }
        .highlight {
            background: #fff3cd;
            padding: 15px;
            border-left: 4px solid #ffc107;
            margin: 20px 0;
        }
        .objectives {
            background: #d1ecf1;
            padding: 20px;
            border-radius: 6px;
            margin: 20px 0;
        }
        .objectives h3 {
            margin-top: 0;
            color: #0c5460;
        }
        .exercise {
            background: #e7f3ff;
            border: 2px solid #007bff;
            border-radius: 6px;
            padding: 20px;
            margin: 20px 0;
        }
        .exercise h3 {
            margin-top: 0;
            color: #007bff;
        }
        .next-lesson {
            background: #d4edda;
            padding: 20px;
            border-radius: 6px;
            margin-top: 30px;
            text-align: center;
        }
    </style>
</head>
<body>
    <div class="lesson-header">
        <div class="lesson-number">Lesson 9 of 12</div>
        <h1>Context API and State Management</h1>
        <div class="lesson-duration">‚è±Ô∏è 35 minutes</div>
    </div>

    <div class="objectives">
        <h3>üéØ Learning Objectives</h3>
        <ul>
            <li>Master the Context API for global state management</li>
            <li>Learn when to use Context vs props</li>
            <li>Implement authentication and theme contexts</li>
            <li>Understand performance considerations</li>
            <li>Build scalable state management patterns</li>
        </ul>
    </div>

    <h2>Understanding the Context API</h2>
    <p>The Context API provides a way to share values between components without explicitly passing props through every level of the tree. It's perfect for global state like themes, user authentication, or language preferences.</p>

    <div class="highlight">
        <strong>üí° When to Use Context:</strong>
        <ul>
            <li>Data needed by many components at different nesting levels</li>
            <li>Avoiding "prop drilling" through multiple components</li>
            <li>Global application state (theme, auth, language)</li>
        </ul>
    </div>

    <h2>Creating and Using Context</h2>
    <div class="code-block">
import React, { createContext, useContext, useState } from 'react';

// 1. Create the context
const UserContext = createContext();

// 2. Create a provider component
function UserProvider({ children }) {
  const [user, setUser] = useState(null);
  const [isLoading, setIsLoading] = useState(false);

  const login = async (email, password) =&gt; {
    setIsLoading(true);
    try {
      // Simulate API call
      const userData = { id: 1, name: 'John Doe', email };
      setUser(userData);
    } catch (error) {
      console.error('Login failed:', error);
    } finally {
      setIsLoading(false);
    }
  };

  const logout = () =&gt; {
    setUser(null);
  };

  const value = {
    user,
    isLoading,
    login,
    logout,
    isAuthenticated: !!user
  };

  return (
    &lt;UserContext.Provider value={value}&gt;
      {children}
    &lt;/UserContext.Provider&gt;
  );
}

// 3. Create a custom hook for easier usage
function useUser() {
  const context = useContext(UserContext);
  if (context === undefined) {
    throw new Error('useUser must be used within a UserProvider');
  }
  return context;
}

// 4. Use the context in components
function LoginForm() {
  const { login, isLoading } = useUser();
  const [email, setEmail] = useState('');
  const [password, setPassword] = useState('');

  const handleSubmit = (e) =&gt; {
    e.preventDefault();
    login(email, password);
  };

  return (
    &lt;form onSubmit={handleSubmit}&gt;
      &lt;input
        type="email"
        value={email}
        onChange={(e) =&gt; setEmail(e.target.value)}
        placeholder="Email"
        required
      /&gt;
      &lt;input
        type="password"
        value={password}
        onChange={(e) =&gt; setPassword(e.target.value)}
        placeholder="Password"
        required
      /&gt;
      &lt;button type="submit" disabled={isLoading}&gt;
        {isLoading ? 'Logging in...' : 'Login'}
      &lt;/button&gt;
    &lt;/form&gt;
  );
}

function UserProfile() {
  const { user, logout, isAuthenticated } = useUser();

  if (!isAuthenticated) {
    return &lt;LoginForm /&gt;;
  }

  return (
    &lt;div&gt;
      &lt;h2&gt;Welcome, {user.name}!&lt;/h2&gt;
      &lt;p&gt;Email: {user.email}&lt;/p&gt;
      &lt;button onClick={logout}&gt;Logout&lt;/button&gt;
    &lt;/div&gt;
  );
}
    </div>

    <h2>Multiple Contexts Pattern</h2>
    <p>You can use multiple contexts for different concerns:</p>

    <div class="code-block">
// Theme Context
const ThemeContext = createContext();

function ThemeProvider({ children }) {
  const [theme, setTheme] = useState('light');
  
  const toggleTheme = () =&gt; {
    setTheme(prev =&gt; prev === 'light' ? 'dark' : 'light');
  };

  return (
    &lt;ThemeContext.Provider value={{ theme, toggleTheme }}&gt;
      {children}
    &lt;/ThemeContext.Provider&gt;
  );
}

// Settings Context
const SettingsContext = createContext();

function SettingsProvider({ children }) {
  const [settings, setSettings] = useState({
    notifications: true,
    language: 'en',
    autoSave: true
  });

  const updateSetting = (key, value) =&gt; {
    setSettings(prev =&gt; ({ ...prev, [key]: value }));
  };

  return (
    &lt;SettingsContext.Provider value={{ settings, updateSetting }}&gt;
      {children}
    &lt;/SettingsContext.Provider&gt;
  );
}

// Combined App Provider
function AppProviders({ children }) {
  return (
    &lt;UserProvider&gt;
      &lt;ThemeProvider&gt;
        &lt;SettingsProvider&gt;
          {children}
        &lt;/SettingsProvider&gt;
      &lt;/ThemeProvider&gt;
    &lt;/UserProvider&gt;
  );
}

// Usage in main App
function App() {
  return (
    &lt;AppProviders&gt;
      &lt;Header /&gt;
      &lt;MainContent /&gt;
      &lt;Footer /&gt;
    &lt;/AppProviders&gt;
  );
}
    </div>

    <h2>Context with useReducer</h2>
    <p>For complex state logic, combine Context with useReducer:</p>

    <div class="code-block">
import React, { createContext, useContext, useReducer } from 'react';

// Action types
const CART_ACTIONS = {
  ADD_ITEM: 'ADD_ITEM',
  REMOVE_ITEM: 'REMOVE_ITEM',
  UPDATE_QUANTITY: 'UPDATE_QUANTITY',
  CLEAR_CART: 'CLEAR_CART'
};

// Reducer function
function cartReducer(state, action) {
  switch (action.type) {
    case CART_ACTIONS.ADD_ITEM:
      const existingItem = state.items.find(item =&gt; item.id === action.payload.id);
      
      if (existingItem) {
        return {
          ...state,
          items: state.items.map(item =&gt;
            item.id === action.payload.id
              ? { ...item, quantity: item.quantity + 1 }
              : item
          )
        };
      }
      
      return {
        ...state,
        items: [...state.items, { ...action.payload, quantity: 1 }]
      };

    case CART_ACTIONS.REMOVE_ITEM:
      return {
        ...state,
        items: state.items.filter(item =&gt; item.id !== action.payload)
      };

    case CART_ACTIONS.UPDATE_QUANTITY:
      return {
        ...state,
        items: state.items.map(item =&gt;
          item.id === action.payload.id
            ? { ...item, quantity: action.payload.quantity }
            : item
        )
      };

    case CART_ACTIONS.CLEAR_CART:
      return {
        ...state,
        items: []
      };

    default:
      throw new Error(`Unknown action type: ${action.type}`);
  }
}

// Context and Provider
const CartContext = createContext();

function CartProvider({ children }) {
  const [state, dispatch] = useReducer(cartReducer, {
    items: [],
    isOpen: false
  });

  // Action creators
  const addItem = (item) =&gt; {
    dispatch({ type: CART_ACTIONS.ADD_ITEM, payload: item });
  };

  const removeItem = (itemId) =&gt; {
    dispatch({ type: CART_ACTIONS.REMOVE_ITEM, payload: itemId });
  };

  const updateQuantity = (itemId, quantity) =&gt; {
    if (quantity &lt;= 0) {
      removeItem(itemId);
    } else {
      dispatch({ 
        type: CART_ACTIONS.UPDATE_QUANTITY, 
        payload: { id: itemId, quantity } 
      });
    }
  };

  const clearCart = () =&gt; {
    dispatch({ type: CART_ACTIONS.CLEAR_CART });
  };

  // Computed values
  const totalItems = state.items.reduce((sum, item) =&gt; sum + item.quantity, 0);
  const totalPrice = state.items.reduce((sum, item) =&gt; sum + (item.price * item.quantity), 0);

  const value = {
    items: state.items,
    totalItems,
    totalPrice,
    addItem,
    removeItem,
    updateQuantity,
    clearCart
  };

  return (
    &lt;CartContext.Provider value={value}&gt;
      {children}
    &lt;/CartContext.Provider&gt;
  );
}

// Custom hook
function useCart() {
  const context = useContext(CartContext);
  if (!context) {
    throw new Error('useCart must be used within CartProvider');
  }
  return context;
}

// Usage in components
function ProductCard({ product }) {
  const { addItem } = useCart();

  return (
    &lt;div className="product-card"&gt;
      &lt;h3&gt;{product.name}&lt;/h3&gt;
      &lt;p&gt;${product.price}&lt;/p&gt;
      &lt;button onClick={() =&gt; addItem(product)}&gt;
        Add to Cart
      &lt;/button&gt;
    &lt;/div&gt;
  );
}

function CartSummary() {
  const { items, totalItems, totalPrice, clearCart } = useCart();

  return (
    &lt;div className="cart-summary"&gt;
      &lt;h3&gt;Cart ({totalItems} items)&lt;/h3&gt;
      &lt;p&gt;Total: ${totalPrice.toFixed(2)}&lt;/p&gt;
      {items.length &gt; 0 && (
        &lt;button onClick={clearCart}&gt;Clear Cart&lt;/button&gt;
      )}
    &lt;/div&gt;
  );
}
    </div>

    <h2>Performance Considerations</h2>
    <p>Context can cause performance issues if not used carefully:</p>

    <div class="code-block">
// ‚ùå Problem: Single context with all state
function AppProvider({ children }) {
  const [user, setUser] = useState(null);
  const [theme, setTheme] = useState('light');
  const [cart, setCart] = useState([]);
  const [notifications, setNotifications] = useState([]);

  // When any value changes, ALL consumers re-render
  const value = { user, theme, cart, notifications, setUser, setTheme, setCart, setNotifications };

  return (
    &lt;AppContext.Provider value={value}&gt;
      {children}
    &lt;/AppContext.Provider&gt;
  );
}

// ‚úÖ Solution: Split contexts by concern
function UserProvider({ children }) {
  const [user, setUser] = useState(null);
  return (
    &lt;UserContext.Provider value={{ user, setUser }}&gt;
      {children}
    &lt;/UserContext.Provider&gt;
  );
}

function ThemeProvider({ children }) {
  const [theme, setTheme] = useState('light');
  return (
    &lt;ThemeContext.Provider value={{ theme, setTheme }}&gt;
      {children}
    &lt;/ThemeContext.Provider&gt;
  );
}

// ‚úÖ Optimize with useMemo for expensive computations
function CartProvider({ children }) {
  const [items, setItems] = useState([]);

  const value = useMemo(() =&gt; ({
    items,
    totalItems: items.reduce((sum, item) =&gt; sum + item.quantity, 0),
    totalPrice: items.reduce((sum, item) =&gt; sum + (item.price * item.quantity), 0),
    setItems
  }), [items]);

  return (
    &lt;CartContext.Provider value={value}&gt;
      {children}
    &lt;/CartContext.Provider&gt;
  );
}
    </div>

    <div class="exercise">
        <h3>üèãÔ∏è Exercise: Build a Multi-Context App</h3>
        <p>Create an app with multiple contexts working together:</p>
        
        <div class="code-block">
// Complete example: Blog app with multiple contexts
function BlogApp() {
  return (
    &lt;AuthProvider&gt;
      &lt;ThemeProvider&gt;
        &lt;PostsProvider&gt;
          &lt;Router&gt;
            &lt;Navbar /&gt;
            &lt;Routes&gt;
              &lt;Route path="/" element={&lt;PostList /&gt;} /&gt;
              &lt;Route path="/post/:id" element={&lt;PostDetail /&gt;} /&gt;
              &lt;Route path="/profile" element={&lt;UserProfile /&gt;} /&gt;
            &lt;/Routes&gt;
          &lt;/Router&gt;
        &lt;/PostsProvider&gt;
      &lt;/ThemeProvider&gt;
    &lt;/AuthProvider&gt;
  );
}

// Navbar component using multiple contexts
function Navbar() {
  const { user, logout } = useAuth();
  const { theme, toggleTheme } = useTheme();
  const { posts } = usePosts();

  return (
    &lt;nav className={`navbar ${theme}`}&gt;
      &lt;div className="nav-brand"&gt;
        &lt;h1&gt;My Blog&lt;/h1&gt;
        &lt;span&gt;{posts.length} posts&lt;/span&gt;
      &lt;/div&gt;
      
      &lt;div className="nav-actions"&gt;
        &lt;button onClick={toggleTheme}&gt;
          {theme === 'light' ? 'üåô' : '‚òÄÔ∏è'}
        &lt;/button&gt;
        
        {user ? (
          &lt;div&gt;
            &lt;span&gt;Welcome, {user.name}&lt;/span&gt;
            &lt;button onClick={logout}&gt;Logout&lt;/button&gt;
          &lt;/div&gt;
        ) : (
          &lt;Link to="/login"&gt;Login&lt;/Link&gt;
        )}
      &lt;/div&gt;
    &lt;/nav&gt;
  );
}
        </div>
        
        <p><strong>Your Task:</strong> Implement the missing providers and components:</p>
        <ul>
            <li>AuthProvider with login/logout functionality</li>
            <li>ThemeProvider with light/dark theme switching</li>
            <li>PostsProvider with CRUD operations for blog posts</li>
            <li>Components that consume multiple contexts</li>
        </ul>
    </div>

    <h2>Context Best Practices</h2>
    <ul>
        <li><strong>Split by concern:</strong> Don't put everything in one context</li>
        <li><strong>Use custom hooks:</strong> Encapsulate context logic in custom hooks</li>
        <li><strong>Provide defaults:</strong> Always provide default values for contexts</li>
        <li><strong>Error boundaries:</strong> Add error handling for context providers</li>
        <li><strong>Optimize performance:</strong> Use useMemo for expensive computations</li>
        <li><strong>Keep it simple:</strong> Don't over-engineer your context structure</li>
    </ul>

    <div class="next-lesson">
        <h3>üéØ Next Up: Performance Optimization</h3>
        <p>Learn advanced techniques for optimizing React applications, including memoization, code splitting, and performance profiling.</p>
    </div>
</body>
</html>