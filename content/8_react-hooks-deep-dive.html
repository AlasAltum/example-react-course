<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>React Hooks Deep Dive</title>
    <style>
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            line-height: 1.6;
            max-width: 800px;
            margin: 0 auto;
            padding: 20px;
            color: #333;
        }
        .lesson-header {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 30px;
            border-radius: 10px;
            margin-bottom: 30px;
            text-align: center;
        }
        .lesson-number {
            font-size: 14px;
            opacity: 0.9;
            margin-bottom: 10px;
        }
        h1 {
            margin: 0;
            font-size: 2.5em;
        }
        .lesson-duration {
            font-size: 16px;
            opacity: 0.9;
            margin-top: 10px;
        }
        .code-block {
            background: #f8f9fa;
            border: 1px solid #e9ecef;
            border-radius: 6px;
            padding: 20px;
            margin: 20px 0;
            font-family: 'Courier New', monospace;
            overflow-x: auto;
        }
        .highlight {
            background: #fff3cd;
            padding: 15px;
            border-left: 4px solid #ffc107;
            margin: 20px 0;
        }
        .objectives {
            background: #d1ecf1;
            padding: 20px;
            border-radius: 6px;
            margin: 20px 0;
        }
        .objectives h3 {
            margin-top: 0;
            color: #0c5460;
        }
        .exercise {
            background: #e7f3ff;
            border: 2px solid #007bff;
            border-radius: 6px;
            padding: 20px;
            margin: 20px 0;
        }
        .exercise h3 {
            margin-top: 0;
            color: #007bff;
        }
        .next-lesson {
            background: #d4edda;
            padding: 20px;
            border-radius: 6px;
            margin-top: 30px;
            text-align: center;
        }
        .warning {
            background: #f8d7da;
            border-left: 4px solid #dc3545;
            padding: 15px;
            margin: 20px 0;
        }
    </style>
</head>
<body>
    <div class="lesson-header">
        <div class="lesson-number">Lesson 8 of 12</div>
        <h1>React Hooks Deep Dive</h1>
        <div class="lesson-duration">‚è±Ô∏è 45 minutes</div>
    </div>

    <div class="objectives">
        <h3>üéØ Learning Objectives</h3>
        <ul>
            <li>Master the useEffect hook for side effects</li>
            <li>Learn useContext for state management</li>
            <li>Understand useReducer for complex state logic</li>
            <li>Explore other built-in hooks</li>
            <li>Create custom hooks for reusable logic</li>
        </ul>
    </div>

    <h2>The useEffect Hook</h2>
    <p>useEffect lets you perform side effects in function components. It serves the same purpose as componentDidMount, componentDidUpdate, and componentWillUnmount combined.</p>

    <div class="code-block">
import React, { useState, useEffect } from 'react';

function DataFetcher() {
  const [data, setData] = useState(null);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState(null);
  
  // Effect runs after every render
  useEffect(() =&gt; {
    console.log('Component rendered');
  });
  
  // Effect runs only once (on mount)
  useEffect(() =&gt; {
    fetchData();
  }, []); // Empty dependency array
  
  // Effect runs when specific values change
  useEffect(() =&gt; {
    document.title = `Data: ${data ? 'Loaded' : 'Loading'}`;
  }, [data]); // Runs when 'data' changes
  
  const fetchData = async () =&gt; {
    try {
      setLoading(true);
      const response = await fetch('https://api.example.com/data');
      const result = await response.json();
      setData(result);
    } catch (err) {
      setError(err.message);
    } finally {
      setLoading(false);
    }
  };
  
  if (loading) return &lt;div&gt;Loading...&lt;/div&gt;;
  if (error) return &lt;div&gt;Error: {error}&lt;/div&gt;;
  
  return (
    &lt;div&gt;
      &lt;h3&gt;Data loaded successfully!&lt;/h3&gt;
      &lt;pre&gt;{JSON.stringify(data, null, 2)}&lt;/pre&gt;
    &lt;/div&gt;
  );
}
    </div>

    <h3>Cleanup with useEffect</h3>
    <div class="code-block">
function Timer() {
  const [seconds, setSeconds] = useState(0);
  
  useEffect(() =&gt; {
    // Set up the interval
    const interval = setInterval(() =&gt; {
      setSeconds(prevSeconds =&gt; prevSeconds + 1);
    }, 1000);
    
    // Cleanup function (runs on unmount or before next effect)
    return () =&gt; {
      clearInterval(interval);
      console.log('Timer cleaned up');
    };
  }, []); // Empty dependency array means this runs once
  
  return (
    &lt;div&gt;
      &lt;h3&gt;Timer: {seconds} seconds&lt;/h3&gt;
    &lt;/div&gt;
  );
}
    </div>

    <h2>The useContext Hook</h2>
    <p>useContext provides a way to pass data through the component tree without having to pass props down manually at every level.</p>

    <div class="code-block">
import React, { createContext, useContext, useState } from 'react';

// Create a context
const ThemeContext = createContext();
const UserContext = createContext();

// Provider component
function AppProvider({ children }) {
  const [theme, setTheme] = useState('light');
  const [user, setUser] = useState({ name: 'John', role: 'admin' });
  
  return (
    &lt;ThemeContext.Provider value={{ theme, setTheme }}&gt;
      &lt;UserContext.Provider value={{ user, setUser }}&gt;
        {children}
      &lt;/UserContext.Provider&gt;
    &lt;/ThemeContext.Provider&gt;
  );
}

// Custom hooks for easier context usage
function useTheme() {
  const context = useContext(ThemeContext);
  if (!context) {
    throw new Error('useTheme must be used within AppProvider');
  }
  return context;
}

function useUser() {
  const context = useContext(UserContext);
  if (!context) {
    throw new Error('useUser must be used within AppProvider');
  }
  return context;
}

// Components using context
function Header() {
  const { theme, setTheme } = useTheme();
  const { user } = useUser();
  
  return (
    &lt;header style={{
      backgroundColor: theme === 'light' ? '#f8f9fa' : '#343a40',
      color: theme === 'light' ? '#000' : '#fff',
      padding: '20px'
    }}&gt;
      &lt;h1&gt;Welcome, {user.name}!&lt;/h1&gt;
      &lt;button onClick={() =&gt; setTheme(theme === 'light' ? 'dark' : 'light')}&gt;
        Switch to {theme === 'light' ? 'Dark' : 'Light'} Theme
      &lt;/button&gt;
    &lt;/header&gt;
  );
}

function App() {
  return (
    &lt;AppProvider&gt;
      &lt;Header /&gt;
      {/* Other components can also use the context */}
    &lt;/AppProvider&gt;
  );
}
    </div>

    <h2>The useReducer Hook</h2>
    <p>useReducer is an alternative to useState for managing complex state logic. It's similar to Redux reducers.</p>

    <div class="code-block">
import React, { useReducer } from 'react';

// Define action types
const ACTIONS = {
  INCREMENT: 'increment',
  DECREMENT: 'decrement',
  RESET: 'reset',
  SET_VALUE: 'set_value'
};

// Reducer function
function counterReducer(state, action) {
  switch (action.type) {
    case ACTIONS.INCREMENT:
      return { count: state.count + 1 };
    case ACTIONS.DECREMENT:
      return { count: state.count - 1 };
    case ACTIONS.RESET:
      return { count: 0 };
    case ACTIONS.SET_VALUE:
      return { count: action.payload };
    default:
      throw new Error(`Unknown action type: ${action.type}`);
  }
}

function Counter() {
  const [state, dispatch] = useReducer(counterReducer, { count: 0 });
  
  return (
    &lt;div&gt;
      &lt;h3&gt;Count: {state.count}&lt;/h3&gt;
      &lt;button onClick={() =&gt; dispatch({ type: ACTIONS.INCREMENT })}&gt;
        +1
      &lt;/button&gt;
      &lt;button onClick={() =&gt; dispatch({ type: ACTIONS.DECREMENT })}&gt;
        -1
      &lt;/button&gt;
      &lt;button onClick={() =&gt; dispatch({ type: ACTIONS.RESET })}&gt;
        Reset
      &lt;/button&gt;
      &lt;button onClick={() =&gt; dispatch({ 
        type: ACTIONS.SET_VALUE, 
        payload: 100 
      })}&gt;
        Set to 100
      &lt;/button&gt;
    &lt;/div&gt;
  );
}
    </div>

    <h2>Other Useful Hooks</h2>

    <h3>useRef - Accessing DOM Elements</h3>
    <div class="code-block">
function FocusInput() {
  const inputRef = useRef(null);
  const [value, setValue] = useState('');
  
  const focusInput = () =&gt; {
    inputRef.current.focus();
  };
  
  const clearAndFocus = () =&gt; {
    setValue('');
    inputRef.current.focus();
  };
  
  return (
    &lt;div&gt;
      &lt;input
        ref={inputRef}
        type="text"
        value={value}
        onChange={(e) =&gt; setValue(e.target.value)}
        placeholder="Type something..."
      /&gt;
      &lt;button onClick={focusInput}&gt;Focus Input&lt;/button&gt;
      &lt;button onClick={clearAndFocus}&gt;Clear & Focus&lt;/button&gt;
    &lt;/div&gt;
  );
}
    </div>

    <h3>useMemo - Performance Optimization</h3>
    <div class="code-block">
function ExpensiveComponent({ items, filter }) {
  // Expensive calculation that we want to memoize
  const filteredItems = useMemo(() =&gt; {
    console.log('Filtering items...'); // This will only run when dependencies change
    return items.filter(item =&gt; 
      item.name.toLowerCase().includes(filter.toLowerCase())
    );
  }, [items, filter]); // Dependencies
  
  const itemCount = useMemo(() =&gt; {
    console.log('Counting items...');
    return filteredItems.length;
  }, [filteredItems]);
  
  return (
    &lt;div&gt;
      &lt;h3&gt;Found {itemCount} items&lt;/h3&gt;
      &lt;ul&gt;
        {filteredItems.map(item =&gt; (
          &lt;li key={item.id}&gt;{item.name}&lt;/li&gt;
        ))}
      &lt;/ul&gt;
    &lt;/div&gt;
  );
}
    </div>

    <h3>useCallback - Memoizing Functions</h3>
    <div class="code-block">
function ParentComponent() {
  const [count, setCount] = useState(0);
  const [name, setName] = useState('');
  
  // Without useCallback, this function is recreated on every render
  const handleClick = useCallback(() =&gt; {
    console.log(`Button clicked! Count: ${count}`);
  }, [count]); // Only recreate when count changes
  
  return (
    &lt;div&gt;
      &lt;input 
        value={name} 
        onChange={(e) =&gt; setName(e.target.value)} 
        placeholder="Type your name"
      /&gt;
      &lt;ChildComponent onClick={handleClick} /&gt;
      &lt;button onClick={() =&gt; setCount(count + 1)}&gt;
        Count: {count}
      &lt;/button&gt;
    &lt;/div&gt;
  );
}

// Child component wrapped in React.memo won't re-render 
// unless its props actually change
const ChildComponent = React.memo(({ onClick }) =&gt; {
  console.log('ChildComponent rendered');
  return &lt;button onClick={onClick}&gt;Click me&lt;/button&gt;;
});
    </div>

    <h2>Custom Hooks</h2>
    <p>Custom hooks let you extract component logic into reusable functions:</p>

    <div class="code-block">
// Custom hook for fetching data
function useFetch(url) {
  const [data, setData] = useState(null);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState(null);
  
  useEffect(() =&gt; {
    const fetchData = async () =&gt; {
      try {
        setLoading(true);
        setError(null);
        const response = await fetch(url);
        if (!response.ok) {
          throw new Error(`HTTP error! status: ${response.status}`);
        }
        const result = await response.json();
        setData(result);
      } catch (err) {
        setError(err.message);
      } finally {
        setLoading(false);
      }
    };
    
    fetchData();
  }, [url]);
  
  return { data, loading, error };
}

// Custom hook for local storage
function useLocalStorage(key, initialValue) {
  const [storedValue, setStoredValue] = useState(() =&gt; {
    try {
      const item = window.localStorage.getItem(key);
      return item ? JSON.parse(item) : initialValue;
    } catch (error) {
      console.error(`Error reading localStorage key "${key}":`, error);
      return initialValue;
    }
  });
  
  const setValue = (value) =&gt; {
    try {
      setStoredValue(value);
      window.localStorage.setItem(key, JSON.stringify(value));
    } catch (error) {
      console.error(`Error setting localStorage key "${key}":`, error);
    }
  };
  
  return [storedValue, setValue];
}

// Using custom hooks
function UserProfile() {
  const { data: user, loading, error } = useFetch('/api/user');
  const [preferences, setPreferences] = useLocalStorage('userPrefs', {
    theme: 'light',
    notifications: true
  });
  
  if (loading) return &lt;div&gt;Loading user...&lt;/div&gt;;
  if (error) return &lt;div&gt;Error: {error}&lt;/div&gt;;
  
  return (
    &lt;div&gt;
      &lt;h2&gt;{user.name}&lt;/h2&gt;
      &lt;p&gt;Theme: {preferences.theme}&lt;/p&gt;
      &lt;button onClick={() =&gt; setPreferences({
        ...preferences,
        theme: preferences.theme === 'light' ? 'dark' : 'light'
      })}&gt;
        Toggle Theme
      &lt;/button&gt;
    &lt;/div&gt;
  );
}
    </div>

    <div class="warning">
        <strong>‚ö†Ô∏è Rules of Hooks:</strong>
        <ul>
            <li>Only call hooks at the top level of your React function</li>
            <li>Don't call hooks inside loops, conditions, or nested functions</li>
            <li>Only call hooks from React function components or custom hooks</li>
        </ul>
    </div>

    <div class="exercise">
        <h3>üèãÔ∏è Exercise: Build a Weather App with Custom Hooks</h3>
        <p>Create a weather app that demonstrates multiple hooks working together:</p>
        
        <div class="code-block">
// Custom hook for geolocation
function useGeolocation() {
  const [location, setLocation] = useState(null);
  const [error, setError] = useState(null);
  const [loading, setLoading] = useState(true);
  
  useEffect(() =&gt; {
    if (!navigator.geolocation) {
      setError('Geolocation is not supported');
      setLoading(false);
      return;
    }
    
    navigator.geolocation.getCurrentPosition(
      (position) =&gt; {
        setLocation({
          latitude: position.coords.latitude,
          longitude: position.coords.longitude
        });
        setLoading(false);
      },
      (error) =&gt; {
        setError(error.message);
        setLoading(false);
      }
    );
  }, []);
  
  return { location, error, loading };
}

// Weather app component
function WeatherApp() {
  const { location, error: locationError, loading: locationLoading } = useGeolocation();
  const [weatherData, setWeatherData] = useState(null);
  const [weatherLoading, setWeatherLoading] = useState(false);
  const [weatherError, setWeatherError] = useState(null);
  const [unit, setUnit] = useLocalStorage('temperatureUnit', 'celsius');
  
  useEffect(() =&gt; {
    if (location) {
      fetchWeather(location.latitude, location.longitude);
    }
  }, [location]);
  
  const fetchWeather = async (lat, lon) =&gt; {
    setWeatherLoading(true);
    setWeatherError(null);
    
    try {
      // Mock API call (replace with real weather API)
      const mockWeatherData = {
        temperature: 22,
        condition: 'Sunny',
        humidity: 65,
        windSpeed: 10,
        city: 'Your City'
      };
      
      // Simulate API delay
      await new Promise(resolve =&gt; setTimeout(resolve, 1000));
      setWeatherData(mockWeatherData);
    } catch (error) {
      setWeatherError('Failed to fetch weather data');
    } finally {
      setWeatherLoading(false);
    }
  };
  
  const convertTemperature = (temp) =&gt; {
    if (unit === 'fahrenheit') {
      return Math.round((temp * 9/5) + 32);
    }
    return temp;
  };
  
  if (locationLoading) {
    return &lt;div&gt;Getting your location...&lt;/div&gt;;
  }
  
  if (locationError) {
    return &lt;div&gt;Location Error: {locationError}&lt;/div&gt;;
  }
  
  return (
    &lt;div style={{ 
      maxWidth: '400px', 
      margin: '0 auto', 
      padding: '20px',
      border: '1px solid #ddd',
      borderRadius: '10px'
    }}&gt;
      &lt;h2&gt;Weather App&lt;/h2&gt;
      
      {weatherLoading && &lt;div&gt;Loading weather...&lt;/div&gt;}
      
      {weatherError && &lt;div&gt;Weather Error: {weatherError}&lt;/div&gt;}
      
      {weatherData && (
        &lt;div&gt;
          &lt;h3&gt;{weatherData.city}&lt;/h3&gt;
          &lt;div style={{ fontSize: '2em', margin: '20px 0' }}&gt;
            {convertTemperature(weatherData.temperature)}¬∞{unit === 'celsius' ? 'C' : 'F'}
          &lt;/div&gt;
          &lt;p&gt;Condition: {weatherData.condition}&lt;/p&gt;
          &lt;p&gt;Humidity: {weatherData.humidity}%&lt;/p&gt;
          &lt;p&gt;Wind Speed: {weatherData.windSpeed} km/h&lt;/p&gt;
          
          &lt;button 
            onClick={() =&gt; setUnit(unit === 'celsius' ? 'fahrenheit' : 'celsius')}
            style={{ 
              padding: '10px 20px', 
              marginTop: '20px',
              backgroundColor: '#007bff',
              color: 'white',
              border: 'none',
              borderRadius: '5px'
            }}
          &gt;
            Switch to {unit === 'celsius' ? 'Fahrenheit' : 'Celsius'}
          &lt;/button&gt;
        &lt;/div&gt;
      )}
    &lt;/div&gt;
  );
}
        </div>
        
        <p><strong>Your Task:</strong> Enhance this weather app by:</p>
        <ul>
            <li>Adding a 5-day forecast</li>
            <li>Implementing city search</li>
            <li>Adding weather icons</li>
            <li>Creating a favorites list</li>
        </ul>
    </div>

    <div class="next-lesson">
        <h3>üéØ Next Up: Context API and State Management</h3>
        <p>We'll dive deeper into the Context API and explore patterns for managing application-wide state in larger React applications.</p>
    </div>
</body>
</html>